#include "SerializerTemplate.hpp"

const char *const SERIALIZER_HEADER_TEMPLATE =
"#pragma once\n"
"\n"
"// This Header was generated with serializer-generator\n"
"\n"
"#include <type_traits>\n"
"#include <iostream>\n"
"\n"
"#ifdef LOG_EVERY_SERIALIZATION\n"
"    #define LOG_SERIALIZATION(variable) { std::cout << variable << std::endl; }\n"
"#else\n"
"    #define LOG_SERIALIZATION(variable)\n"
"#endif\n"
"\n"
"/// @brief This macro should only be used in header files because the record\n"
"///        needs to be included in the .cpp file of the serializer.\n"
"#define AUTO_SERIALIZE                                                         \\\n"
"    using enable_auto_serialize = void;                                        \\\n"
"    friend class Serializer;                                                   \\\n"
"    friend class Unserializer;                                                 \\\n"
"    void serialize(std::ostream &os) const                                     \\\n"
"    {                                                                          \\\n"
"        Serializer serializer(os);                                             \\\n"
"        serializer(*this);                                                     \\\n"
"    }                                                                          \\\n"
"    void unserialize(std::istream &is)                                         \\\n"
"    {                                                                          \\\n"
"        Unserializer unserializer(is);                                         \\\n"
"        unserializer(*this);                                                   \\\n"
"    }\n"
"\n"
"template<typename T>\n"
"concept array_type = requires(T t) {\n"
"    t.size();\n"
"    t.data();\n"
"    requires std::is_pointer_v<decltype(t.data())>;\n"
"    t[0];\n"
"    requires std::is_reference_v<decltype(t[0])>;\n"
"    t.resize(t.size());\n"
"};\n"
"\n"
"template<typename T>\n"
"concept trivially_copyable = std::is_trivially_copyable_v<T>;\n"
"\n"
"// @FORWARD_DECLARATIONS@\n"
"\n"
"class Serializer {\n"
"public:\n"
"    Serializer(std::ostream &os)\n"
"        : m_os(os)\n"
"    {}\n"
"\n"
"    void operator()(const array_type auto &field) {\n"
"        using size_type = decltype(field.size());\n"
"        const size_type size = field.size();\n"
"\n"
"        LOG_SERIALIZATION(\"Aggregate of size: \" << size);\n"
"        m_os.write(reinterpret_cast<const char*>(&size), sizeof(size));\n"
"        for (size_type i = 0; i < size; i++)\n"
"        {\n"
"            (*this)(field[i]);\n"
"        }\n"
"    }\n"
"\n"
"    void operator()(const trivially_copyable auto &field)\n"
"    {\n"
"        LOG_SERIALIZATION(field);\n"
"        m_os.write(reinterpret_cast<const char*>(&field), sizeof(field));\n"
"    }\n"
"\n"
"    void operator()(const auto &object) { static_assert(false, \"The Serializer classes need regeneration.\"); }\n"
"\n"
"// @SERIALIZER_DECLARATIONS@\n"
"\n"
"private:\n"
"    std::ostream &m_os;\n"
"};\n"
"\n"
"class Unserializer {\n"
"public:\n"
"    Unserializer(std::istream &is)\n"
"        : m_is(is)\n"
"    {}\n"
"\n"
"    void operator()(array_type auto &field)\n"
"    {\n"
"        using size_type = decltype(field.size());\n"
"        size_type size;\n"
"        m_is.read(reinterpret_cast<char*>(&size), sizeof(size));\n"
"        LOG_SERIALIZATION(\"Aggregate of size: \" << size);\n"
"        field.resize(size);\n"
"        for (size_type i = 0; i < size; i++)\n"
"        {\n"
"            (*this)(field[i]);\n"
"        }\n"
"    }\n"
"\n"
"    void operator()(trivially_copyable auto &field)\n"
"    {\n"
"        m_is.read(reinterpret_cast<char*>(&field), sizeof(field));\n"
"        LOG_SERIALIZATION(field);\n"
"    }\n"
"\n"
"    void operator()(auto &object) { static_assert(false, \"The Serializer classes need regeneration.\"); }\n"
"\n"
"// @UNSERIALIZER_DECLARATIONS@\n"
"\n"
"private:\n"
"    std::istream &m_is;\n"
"};\n"
"\n"
;
